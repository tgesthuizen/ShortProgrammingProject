\documentclass[12pt, article]{article}

\author{Tim Gesthuizen}
\title{Logbook}

\setlength{\parindent}{0ex}
\setlength{\parskip}{1.5ex}

\usepackage{listings}

\begin{document}

\maketitle

\section{2022-11-17}

\subsection{What happened today?}

\begin{itemize}
\item Parsing works okay for simple programs
\item The scopify and typecheck passes work as well
\item The name of the language is decided to be ``lyn'' for now.
  The short name saves typing and having a name is better than
  bikeshedding for days what would be a good one.
\item Added this document to have a time-representing documentation of
  the project.
\end{itemize}

\subsection{Some questions came up}

\begin{itemize}
\item What would be a good intermediate format to translate to ARM
  instructions? (Suspected to be K-normal forms, like mincaml uses)
\item What would be a good separation for the project?
\item What would be a good first target platform?
\item How would a hand-written recursive descent parser compare to the
  GNU Bison one?
\end{itemize}

\subsection{New ideas}

I guess it would make most sense to develop the compiler in three
pulls:
\begin{enumerate}
\item Build a version that has no primitives nor register allocation
  whatsoever.
  This is easy to implement and a nice comparison for later
  developments.
  Code generated by this version will be trivial and horrible.
\item Then add primitive handling and get rid of some superflous calls
  that can be replaced with simple machine instructions.
\item At last add register allocation.
\end{enumerate}

Maybe step 2 and 3 can be swapped, although it seems safest to
approach it in the way written down.

\subsection{Notes of today}

The amount of memory allocations being done is worrying.
Especially the type system probably needs some reworking before it can
be ported to embedded systems.
Also types are never ever freed by the program yet, but don't tell
anyone.
Right now it seems that types can be dropped after they are checked so
I might just allocate them in a separate heap and drop it altogether
once IR translation has been done.

\section{2022-11-18}

\subsection{What happened today?}

It was decided that ANF (A-normal forms) is the intermediate
representation of choice for now.
A pass that implements the parsed AST into this format has started
being developed.

\subsection{Questions that came up}

Is the way non-tail if expressions are handeled sufficient?
It seems I might need to add phi nodes as SSA compilers like LLVM use
in order to nail the exact details.
I also expect this to lead to some brain melt when developing a proper
register allocator.

\subsection{New ideas}

My view of what the first backend should be is still somewhat vague,
but a textual assembly output seems to be the lowest hanging fruit.
Especially as this can be gracefully expanded to full ELF relocatable
output.
There is also the idea of a makeshift LLVM backend, but this makes
writing an own backend basically obsolete, as there is no need for
it.
Also this approach immediatly destroys any hope of porting the
compiler in the current form onto an embedded platform.

\subsection{Notes of today}

While the ANF pass itself was challenging to implement\footnote{Still
  I got away with implementing it without a design session
  upfront. Wohoo!?}, but of comprehensible complexity, the amount of
details that need adjustment for optimal code generation seems
overwhelming.
I'm not yet bothered as the current goal is getting correct code
generation, not fast code generation, but this is something to keep in
mind.


Sometime soon it might be of value to have some documentation of the
internal structure of the compiler (eww, yet another document to
maintain).
For now I procrastinate on this as I am not yet 100\% convinced that
the current design will work out.

\section{2022-11-19}

\subsection{What happened today?}

Hooked up the ANF pass and found it to be pretty functional.
Fixed a bug here and there and apparently I am able to generate pretty
okay IR code:

\begin{lstlisting}
tibbe@finkpad:~/src/spp$ build/lyn examples/gcd.scm
<global> gcd:
.L0:
        23, 24 <- receive
        25 <- global "="
        26 <- const 0
        27 <- call 25(24, 26)
        if 27: 1 2
.L1:
        ret 23
.L2:
        28 <- global "gcd"
        29 <- global "/"
        30 <- call 29(23, 24)
        tailcall 28(24, 30)
\end{lstlisting}

\end{document}